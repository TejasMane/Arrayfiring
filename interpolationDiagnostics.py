import numpy as np
from scipy.special import erfinv
import h5py
import params
import pylab as pl

# Some common terms 

no_of_particles      = params.no_of_particles
choice_integrator    = params.choice_integrator
collision_operator   = params.collision_operator

plot_spatial_temperature_profile = params.plot_spatial_temperature_profile

if(plot_spatial_temperature_profile == "true"):
  x_zones_temperature = params.x_zones_temperature
  y_zones_temperature = params.y_zones_temperature

elif(collision_operator == "potential-based"):
  potential_steepness     = params.potential_steepness
  potential_amplitude     = params.potential_amplitude
  order_finite_difference = params.order_finite_difference

elif(collision_operator == "montecarlo"):
  x_zones_montecarlo = params.x_zones_montecarlo
  y_zones_montecarlo = params.y_zones_montecarlo
  
mass_particle      = params.mass_particle
boltzmann_constant = params.boltzmann_constant
T_initial          = params.T_initial
wall_condition_x   = params.wall_condition_x
wall_condition_y   = params.wall_condition_y
wall_condition_z   = params.wall_condition_z

if(wall_condition_x == "thermal"):
  T_left_wall  = params.T_left_wall
  T_right_wall = params.T_right_wall

if(wall_condition_y == "thermal"):
  T_top_wall = params.T_top_wall
  T_bot_wall = params.T_bot_wall

if(wall_condition_z == "thermal"):
  T_front_wall = params.T_front_wall
  T_back_wall  = params.T_back_wall

fields_enabled   = params.fields_enabled

if(fields_enabled == "true"):
  spread            = params.spread
  ghost_cells       = params.ghost_cells
  speed_of_light    = params.speed_of_light
  charge            = params.charge
  x_zones_field     = params.x_zones_field
  y_zones_field     = params.y_zones_field

left_boundary    = params.left_boundary
right_boundary   = params.right_boundary
length_box_x     = params.length_box_x

bottom_boundary  = params.bottom_boundary
top_boundary     = params.top_boundary
length_box_y     = params.length_box_y

back_boundary    = params.back_boundary
front_boundary   = params.front_boundary
length_box_z     = params.length_box_z

# Here we complete import of all the variable from the parameters file

# Now we shall read the data that was generated by initialize.py
# This would provide us our initial conditions(at t = 0) for the simulation

h5f           = h5py.File('data_files/initial_conditions/initial_data.h5', 'r')
x_initial     = h5f['x_coords'][:]
y_initial     = h5f['y_coords'][:]
vel_x_initial = h5f['vel_x'][:]
vel_y_initial = h5f['vel_y'][:]
time          = h5f['time'][:]
x_center      = h5f['x_center'][:]
y_center      = h5f['y_center'][:]
x_right       = h5f['x_right'][:]
y_top         = h5f['y_top'][:]
z_initial     = h5f['z_coords'][:]
vel_z_initial = h5f['vel_z'][:]
h5f.close()

# Considering a non-adaptive time-stepping, the time-step size for the entire simulation would be
dt = time[1] - time[0]

"""Declaring data variables which shall be used in post-processing"""

# These variables will be written to file at the end of every 100 time-steps
# This frequency of writing to the disc may be changed below

momentum_x     = np.zeros(time.size)
momentum_y     = np.zeros(time.size)
momentum_z     = np.zeros(time.size)
kinetic_energy = np.zeros(time.size)
pressure       = np.zeros(time.size)
heatflux_x     = np.zeros(time.size)
heatflux_y     = np.zeros(time.size)
heatflux_z     = np.zeros(time.size)

if(collision_operator == "potential-based"):
  potential_energy = np.zeros(time.size)

"""Choice for integrators"""

if(choice_integrator == "verlet"):
  from integrators.verlet import integrator

"""Setting the wall options"""

if(wall_condition_x == "thermal"):
  from wall_options.thermal import wall_x
elif(wall_condition_x == "hardwall"):
  from wall_options.hard_wall import wall_x
elif(wall_condition_x == "periodic"):
  from wall_options.periodic import wall_x

if(wall_condition_y == "thermal"):
  from wall_options.thermal import wall_y
elif(wall_condition_y == "hardwall"):
  from wall_options.hard_wall import wall_y
elif(wall_condition_y == "periodic"):
  from wall_options.periodic import wall_y

if(wall_condition_z == "thermal"):
  from wall_options.thermal import wall_z
elif(wall_condition_z == "hardwall"):
  from wall_options.hard_wall import wall_z
elif(wall_condition_z == "periodic"):
  from wall_options.periodic import wall_z

"""Collision Options"""

if(collision_operator == "montecarlo"):
  from collision_operators.monte_carlo import collision_operator

# We shall define a collision operator for the potential based model and collisionless models as well,
# Although integrator takes care of the scattering itself. The operator shall return the values as is
# This is to avoid condition checking inside the time-loop

if(collision_operator == "potential-based"):
  from collision_operators.potential import collision_operator

if(collision_operator == "collisionless"):
  from collision_operators.collisionless import collision_operator
  
  
  
  
def sumsum(a):

  return sum(sum(abs(a)))
  
  
def initial_fields(x, y):

  function_value = np.sin(2 * np.pi * x * y) * np.cos(2 * np.pi * x * y)

  return function_value
  
# Now we shall proceed to evolve the system with time:

""" Error function """

def interpolation_error_convergence(a, b):

  print('Computing error for Nx = ', a, 'Ny = ', b)

  """ Getting the two dimension matrix for initializing the fields """

  Nx = a  # number of zones not points
  Ny = b  # number of zones not points

  """ Length of each zone along x and y """

  Lx = right_boundary - left_boundary
  Ly = top_boundary - bottom_boundary

  dx = np.float(Lx / (Nx))
  dy = np.float(Ly / (Ny))

  """ Initializing the spatial grids"""

  #np.linspace(start point, endpoint, number of points, endpoint = Tue/False)

  x_center = np.linspace(-ghost_cells*dx, Lx + ghost_cells*dx, Nx + 1 + 2 * ghost_cells, endpoint=True)
  y_center = np.linspace(-ghost_cells*dy, Ly + ghost_cells*dy, Ny + 1 + 2 * ghost_cells, endpoint=True)



  x_right = np.linspace(-ghost_cells * dx / 2, Lx + (2 * ghost_cells + 1) * dx / 2, Nx + 1 + 2 * ghost_cells,\
                          endpoint=True\
                       )

  y_top   = np.linspace(-ghost_cells * dy / 2, Ly + (2 * ghost_cells + 1) * dy / 2, Ny + 1 + 2 * ghost_cells,\
                        endpoint=True\
                       )

  """ Initializing the field variables """

  Ez = np.zeros(((len(x_center)), (len(y_center))), dtype=np.float)
  Bx = np.zeros(((len(x_center)), (len(y_center))), dtype=np.float)
  By = np.zeros(((len(x_center)), (len(y_center))), dtype=np.float)

  """ Getting the two dimension matrix for initializing the fields """

  X_center_physical, Y_center_physical = np.meshgrid( x_center[ghost_cells:-ghost_cells],\
                                                      y_center[ghost_cells:-ghost_cells]\
                                                    )

  X_right_physical, Y_top_physical     = np.meshgrid( x_right[ghost_cells:-ghost_cells],\
                                                      y_top[ghost_cells:-ghost_cells]\
                                                    )

  """ [-ghostcells:ghostcells] selects the points located in the physical domain excluding the ghost cells """

  """ Assigning Field values to the physical physical domain """
  # You can change the initialization here but to get the correct convergence plots make sure error is
  # computed correctly

  Ez[ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = initial_fields( X_center_physical,\
                                                                           Y_center_physical
                                                                         )

  Bx[ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = initial_fields( X_center_physical,\
                                                                           Y_top_physical\
                                                                         )

  By[ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = initial_fields( X_right_physical,\
                                                                           Y_center_physical\
                                                                         )

  """ Implementing Periodic Boundary conditions using ghost cells """

  from wall_options.EM_periodic import periodic

  Ez = periodic(Ez, len(x_center), len(y_center), ghost_cells )
  Bx = periodic(Bx, len(x_center), len(y_top), ghost_cells    )
  By = periodic(By, len(x_right), len(y_center), ghost_cells  )

  """ Selecting a number of test points for testing error """

  number_random_points = 100

  x_random = np.random.rand(number_random_points)
  y_random = np.random.rand(number_random_points)

  """ Selecting a number of test points for testing error """

  Ez_at_random = np.zeros(number_random_points)
  Bx_at_random = np.zeros(number_random_points)
  By_at_random = np.zeros(number_random_points)

  """ Calculating interpolated values at the randomly selected points """

  from fields.interpolator import bilinear_interpolate
  
  Ez_at_random = np.array( bilinear_interpolate( x=[x_random], y=[y_random], x_grid=x_center,\
                                                 y_grid=y_center, F=Ez, ghost_cells = 1, Lx = Lx, Ly = Ly\
                                               )\
                         )

  Bx_at_random = np.array( bilinear_interpolate( x=[x_random], y=[y_random], x_grid=x_center,\
                                                 y_grid=y_top, F=Bx, ghost_cells = 1, Lx = Lx, Ly = Ly\
                                               )\
                         )

  By_at_random = np.array( bilinear_interpolate( x=[x_random], y=[y_random], x_grid=x_right,\
                                                 y_grid=y_center, F=By, ghost_cells = 1, Lx = Lx, Ly = Ly\
                                               )\
                         )

  """ Calculating average errors in the interpolated values at the randomly selected points """

  # Make sure the analytical results at the interpolated points are correct to get 2nd order convergence

  Ez_error = sumsum(Ez_at_random - [initial_fields(x_random, y_random)]) / number_random_points
  Bx_error = sumsum(Bx_at_random - [initial_fields(x_random, y_random)]) / number_random_points
  By_error = sumsum(By_at_random - [initial_fields(x_random, y_random)]) / number_random_points

  return np.array(Ez_error), np.array(Bx_error), np.array(By_error)


""" Vectorizing the output of the error function"""

interpolation_error_convergence = np.vectorize(interpolation_error_convergence)

""" Choosing test grid densities """

# change N here as desired for the convergence test

# N = np.array([32, 64, 128, 256, 512, 1024])

N = np.arange(100, 3000, 100)

""" Computing error at the corresponding grid densities """

error_N_Ez, error_N_Bx, error_N_By = interpolation_error_convergence(N, N)

""" Plotting error vs grid density """

# Change this following segment to get plots as desired

pl.loglog(N, error_N_Ez, '-o', lw=3, label='$E_z$ ')
pl.legend()
pl.loglog(N, error_N_Bx, '-o', lw=3, label='$B_x$ ')
pl.legend()
pl.loglog(N, error_N_By, '-o', lw=5, label='$B_y$ ')
pl.legend()
pl.loglog(N, 150 * (N ** -1.999), '--', color='black', lw=2, label=' $O(N^{-2})$ ')
pl.legend()
pl.title('$\mathrm{Convergence\; plot}$ ')
pl.xlabel('$\mathrm{N}$')
pl.ylabel('$\mathrm{L_1\;norm\;of\;error}$')
pl.show()
pl.clf() 
