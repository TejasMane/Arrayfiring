import numpy as np
import h5py
import params
import arrayfire as af

print(af.device.device_info())

"""
x, E, rho at t = (n) * dt
v, B, J   at t = (n + 0.5) * dt
"""

"""Here we shall re-assign values as set in params"""

no_of_particles      = params.no_of_particles
choice_integrator    = params.choice_integrator
collision_operator   = params.collision_operator

plot_spatial_temperature_profile = params.plot_spatial_temperature_profile

if(plot_spatial_temperature_profile == "true"):
  x_zones_temperature = params.x_zones_temperature
  y_zones_temperature = params.y_zones_temperature

elif(collision_operator == "potential-based"):
  potential_steepness     = params.potential_steepness
  potential_amplitude     = params.potential_amplitude
  order_finite_difference = params.order_finite_difference

elif(collision_operator == "montecarlo"):
  x_zones_montecarlo = params.x_zones_montecarlo
  y_zones_montecarlo = params.y_zones_montecarlo

mass_particle      = params.mass_particle
boltzmann_constant = params.boltzmann_constant
T_initial          = params.T_initial
wall_condition_x   = params.wall_condition_x
wall_condition_y   = params.wall_condition_y
wall_condition_z   = params.wall_condition_z

if(wall_condition_x == "thermal"):
  T_left_wall  = params.T_left_wall
  T_right_wall = params.T_right_wall

if(wall_condition_y == "thermal"):
  T_top_wall = params.T_top_wall
  T_bot_wall = params.T_bot_wall

if(wall_condition_z == "thermal"):
  T_front_wall = params.T_front_wall
  T_back_wall  = params.T_back_wall

fields_enabled   = params.fields_enabled

if(fields_enabled == "true"):
  spread              = params.spread
  ghost_cells         = params.ghost_cells
  speed_of_light      = params.speed_of_light
  charge              = params.charge
  x_zones_field       = params.x_zones_field
  y_zones_field       = params.y_zones_field
  k_fourier           = params.k_fourier
  Amplitude_perturbed = params.Amplitude_perturbed

left_boundary    = params.left_boundary
right_boundary   = params.right_boundary
length_box_x     = params.length_box_x

bottom_boundary  = params.bottom_boundary
top_boundary     = params.top_boundary
length_box_y     = params.length_box_y

back_boundary    = params.back_boundary
front_boundary   = params.front_boundary
length_box_z     = params.length_box_z

# Here we complete import of all the variable from the parameters file

# Now we shall read the data that was generated by initialize.py
# This would provide us our initial conditions(at t = 0) for the simulation

h5f           = h5py.File('data_files/initial_conditions/initial_data.h5', 'r')

x_initial     = h5f['x_coords'][:]
x_initial     = af.to_array(x_initial)

y_initial     = h5f['y_coords'][:]
y_initial     = (af.to_array(y_initial)).as_type(af.Dtype.f64)

vel_x_initial = h5f['vel_x'][:]
vel_x_initial = af.to_array(vel_x_initial)

vel_y_initial = h5f['vel_y'][:]
vel_y_initial = af.to_array(vel_y_initial)

time          = h5f['time'][:]
print('time length', time.size)
x_center      = h5f['x_center'][:]
x_center      = af.to_array(x_center)

y_center      = h5f['y_center'][:]
y_center      = af.to_array(y_center)

x_right       = h5f['x_right'][:]
x_right        = af.to_array(x_center)

y_top         = h5f['y_top'][:]
y_top         = af.to_array(y_center)

z_initial     = h5f['z_coords'][:]
z_initial     = af.to_array(z_initial)

vel_z_initial = h5f['vel_z'][:]
vel_z_initial     = af.to_array(vel_z_initial)

h5f.close()

# Considering a non-adaptive time-stepping, the time-step size for the entire simulation would be
dt = time[1] - time[0]

"""Declaring data variables which shall be used in post-processing"""

# These variables will be written to file at the end of every 100 time-steps
# This frequency of writing to the disc may be changed below

#momentum_x     = np.zeros(time.size)
#momentum_y     = np.zeros(time.size)
#momentum_z     = np.zeros(time.size)
#kinetic_energy = np.zeros(time.size)
#pressure       = np.zeros(time.size)
#heatflux_x     = np.zeros(time.size)
#heatflux_y     = np.zeros(time.size)
#heatflux_z     = np.zeros(time.size)

if(collision_operator == "potential-based"):
  potential_energy = np.zeros(time.size)

"""Choice for integrators"""

if(choice_integrator == "verlet"):
  from integrators.verlet import integrator

"""Setting the wall options"""

if(wall_condition_x == "thermal"):
  from wall_options.thermal import wall_x
elif(wall_condition_x == "hardwall"):
  from wall_options.hard_wall import wall_x
elif(wall_condition_x == "periodic"):
  from wall_options.periodic import wall_x

if(wall_condition_y == "thermal"):
  from wall_options.thermal import wall_y
elif(wall_condition_y == "hardwall"):
  from wall_options.hard_wall import wall_y
elif(wall_condition_y == "periodic"):
  from wall_options.periodic import wall_y

if(wall_condition_z == "thermal"):
  from wall_options.thermal import wall_z
elif(wall_condition_z == "hardwall"):
  from wall_options.hard_wall import wall_z
elif(wall_condition_z == "periodic"):
  from wall_options.periodic import wall_z


if(fields_enabled == "true"):
  from fields.fdtd import fdtd
  from integrators.magnetic_verlet import integrator
  from fields.current_depositor import dcd, current_b1_depositor, charge_b1_depositor, Umeda_2003
  Ez = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)
  Bx = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)
  By = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)

  Bz = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)
  Ex = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)
  Ey = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)

  Ez_particle = af.data.constant(0, no_of_particles, dtype=af.Dtype.f64)
  Bx_particle = af.data.constant(0, no_of_particles, dtype=af.Dtype.f64)
  By_particle = af.data.constant(0, no_of_particles, dtype=af.Dtype.f64)

  Bz_particle = af.data.constant(0, no_of_particles, dtype=af.Dtype.f64)
  Ex_particle = af.data.constant(0, no_of_particles, dtype=af.Dtype.f64)
  Ey_particle = af.data.constant(0, no_of_particles, dtype=af.Dtype.f64)

  Jx = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)
  Jy = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)
  Jz = af.data.constant(0, y_center.elements(), x_center.elements(), dtype=af.Dtype.f64)

  X_center_physical = af.tile(af.reorder(x_center[ghost_cells:-ghost_cells],1), y_center[ghost_cells:-ghost_cells].elements(),1)

  X_right_physical  = af.tile(af.reorder(x_right[ghost_cells:-ghost_cells],1), y_center[ghost_cells:-ghost_cells].elements(),1)

  Y_center_physical = af.tile(y_center[ghost_cells:-ghost_cells], 1, x_center[ghost_cells:-ghost_cells].elements())

  Y_top_physical    = af.tile(y_top[ghost_cells:-ghost_cells], 1, x_center[ghost_cells:-ghost_cells].elements())

  ## Initializing the fields:

  dx = length_box_x/x_zones_field
  dy = length_box_y/y_zones_field
  # At time t = 0 * dt
  Ex [ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = charge * Amplitude_perturbed * (1/k_fourier) * \
                                                           af.arith.sin(k_fourier*(X_right_physical))
  # print('Ex initialized is ', Ex)
# Now we shall proceed to evolve the system with time:
from fields.interpolator import zone_finder, fraction_finder

for time_index,t0 in enumerate(time):

  if(time_index%100==0):
    print("Computing for Time Index = ", time_index)
    print() # This is to print a blank line

  if(time_index == time.size-1):
    break

  Jx[:, :], Jy[:, :], Jz[:, :] = 0, 0, 0

  # Getting Jx, Jy, Jz at t = (n + 0.5) * dt from x(n * dt) and v at (n + 0.5) * dt
  # Jx, Jy, Jz = dcd( charge, no_of_particles, x_initial, y_initial, \
  #                 z_initial, vel_x_initial, vel_y_initial, vel_z_initial, x_center, \
  #                 y_center, current_b1_depositor, ghost_cells,length_box_x, length_box_y, dx, dy, dt \
  #               )


  Jx, Jy, Jz = Umeda_2003(charge, no_of_particles, x_initial ,y_initial, z_initial, vel_x_initial, vel_y_initial, vel_z_initial, \
                  x_center, y_center, ghost_cells, length_box_x, length_box_y, dx, dy, dt\
                )

  Jx = Jx/no_of_particles
  Jy = Jy/no_of_particles
  Jz = Jz/no_of_particles
  # Getting E((n + 1) * dt) and B((n + 1 + 0.5) * dt) from E(n * dt) and B((n + 0.5) * dt)
  Ex_updated, Ey_updated, Ez_updated, Bx_updated, By_updated, Bz_updated = fdtd( Ex, Ey, Ez, Bx, By, Bz, \
                                                                                 speed_of_light, length_box_x,\
                                                                                 length_box_y, ghost_cells, Jx, Jy,\
                                                                                 Jz, dt, no_of_particles\
                                                                               )

  # finding fractional positions for interpolating fields for x((n + 1) * dt)

  fracs_Ex_x, fracs_Ex_y = fraction_finder(x_initial + vel_x_initial * dt,\
                                           y_initial + vel_y_initial * dt, \
                                           x_right, y_center)

  fracs_Ey_x, fracs_Ey_y = fraction_finder(x_initial + vel_x_initial * dt,\
                                           y_initial + vel_y_initial * dt, \
                                           x_right, y_center)

  fracs_Ez_x, fracs_Ez_y = fraction_finder(x_initial + vel_x_initial * dt,\
                                           y_initial + vel_y_initial * dt, \
                                           x_right, y_center)

  fracs_Bx_x, fracs_Bx_y = fraction_finder(x_initial + vel_x_initial * dt,\
                                           y_initial + vel_y_initial * dt, \
                                           x_right, y_center)

  fracs_By_x, fracs_By_y = fraction_finder(x_initial + vel_x_initial * dt,\
                                           y_initial + vel_y_initial * dt, \
                                           x_right, y_center)

  fracs_Bz_x, fracs_Bz_y = fraction_finder(x_initial + vel_x_initial * dt,\
                                           y_initial + vel_y_initial * dt, \
                                           x_right, y_center)

  # Find E(x[(n + 1) * dt]) and B(x[(n + 1) * dt])

  Ex_particle = af.signal.approx2(Ex_updated, fracs_Ex_y, fracs_Ex_x)

  Ey_particle = af.signal.approx2(Ey_updated, fracs_Ey_y, fracs_Ey_x)

  Ez_particle = af.signal.approx2(Ez_updated, fracs_Ez_y, fracs_Ez_x)

  Bx_particle = af.signal.approx2((Bx + Bx_updated)/2, fracs_Bx_y, fracs_Bx_x)

  By_particle = af.signal.approx2((By + By_updated)/2, fracs_By_y, fracs_By_x)

  Bz_particle = af.signal.approx2((Bz + Bz_updated)/2, fracs_Bz_y, fracs_Bz_x)



  # UPDATING THE PARTICLE COORDINATES USING BORIS ALGORITHM
  # Input x(n), v(n + 0.5), E(x(n + 1)) and B(n + 1)
  (x_coords, y_coords, z_coords, vel_x, vel_y, vel_z) = integrator(mass_particle, charge, x_initial, y_initial, z_initial,\
                                                                   vel_x_initial, vel_y_initial, vel_z_initial, dt, \
                                                                   Ex_particle, Ey_particle, Ez_particle,\
                                                                   Bx_particle, By_particle, Bz_particle\
                                                                  )

  # SAVING THE FIELDS FOR NEXT TIME STEP

  Ex, Ey, Ez, Bx, By, Bz = Ex_updated.copy(), Ey_updated.copy(), Ez_updated.copy(), Bx_updated.copy(), By_updated.copy(), Bz_updated.copy()


  (x_coords, vel_x, vel_y, vel_z) = wall_x(x_coords, vel_x, vel_y, vel_z)
  (y_coords, vel_x, vel_y, vel_z) = wall_y(y_coords, vel_x, vel_y, vel_z)
  (z_coords, vel_x, vel_y, vel_z) = wall_z(z_coords, vel_x, vel_y, vel_z)


  ## Here, we shall set assign the values to variables which shall be used as a starting point for the next time-step

  x_initial = x_coords.copy()
  y_initial = y_coords.copy()
  z_initial = z_coords.copy()

  vel_x_initial = vel_x.copy()
  vel_y_initial = vel_y.copy()
  vel_z_initial = vel_z.copy()


  if(time_index%100==0):
    # print('vel y',af.sum(af.abs(vel_y)))
    # print('Bz',af.sum(af.abs(Bz)))
    h5f = h5py.File('data_files/timestepped_data/solution_'+str(time_index)+'.h5', 'w')
    h5f.create_dataset('x_coords',   data = x_coords)
    h5f.create_dataset('vel_x',   data = vel_x)
    h5f.create_dataset('Ex',   data = (Ex))
    h5f.close()
