import numpy as np
from scipy.special import erfinv
import h5py
import params
import pylab as pl
from scipy import signal
from initialize import final_time



# Some common terms

no_of_particles      = params.no_of_particles
choice_integrator    = params.choice_integrator
collision_operator   = params.collision_operator

plot_spatial_temperature_profile = params.plot_spatial_temperature_profile

if(plot_spatial_temperature_profile == "true"):
  x_zones_temperature = params.x_zones_temperature
  y_zones_temperature = params.y_zones_temperature

elif(collision_operator == "potential-based"):
  potential_steepness     = params.potential_steepness
  potential_amplitude     = params.potential_amplitude
  order_finite_difference = params.order_finite_difference

elif(collision_operator == "montecarlo"):
  x_zones_montecarlo = params.x_zones_montecarlo
  y_zones_montecarlo = params.y_zones_montecarlo
  
mass_particle      = params.mass_particle
boltzmann_constant = params.boltzmann_constant
T_initial          = params.T_initial
wall_condition_x   = params.wall_condition_x
wall_condition_y   = params.wall_condition_y
wall_condition_z   = params.wall_condition_z

if(wall_condition_x == "thermal"):
  T_left_wall  = params.T_left_wall
  T_right_wall = params.T_right_wall

if(wall_condition_y == "thermal"):
  T_top_wall = params.T_top_wall
  T_bot_wall = params.T_bot_wall

if(wall_condition_z == "thermal"):
  T_front_wall = params.T_front_wall
  T_back_wall  = params.T_back_wall

fields_enabled   = params.fields_enabled

if(fields_enabled == "true"):
  spread            = params.spread
  ghost_cells       = params.ghost_cells
  speed_of_light    = params.speed_of_light
  charge            = params.charge
  x_zones_field     = params.x_zones_field
  y_zones_field     = params.y_zones_field
  forward_row       = params.forward_row
  forward_column    = params.forward_column
  backward_row      = params.backward_row
  backward_column   = params.backward_column
  no_of_particles   = params.no_of_particles
  mass_particle     = params.mass_particle
  charge            = params.charge
  
  

left_boundary    = params.left_boundary
right_boundary   = params.right_boundary
length_box_x     = params.length_box_x

bottom_boundary  = params.bottom_boundary
top_boundary     = params.top_boundary
length_box_y     = params.length_box_y

back_boundary    = params.back_boundary
front_boundary   = params.front_boundary
length_box_z     = params.length_box_z

# Here we complete import of all the variable from the parameters file

# Now we shall read the data that was generated by initialize.py
# This would provide us our initial conditions(at t = 0) for the simulation

h5f           = h5py.File('data_files/initial_conditions/initial_data.h5', 'r')
x_initial     = h5f['x_coords'][:]
y_initial     = h5f['y_coords'][:]
vel_x_initial = h5f['vel_x'][:]
vel_y_initial = h5f['vel_y'][:]
time          = h5f['time'][:]
x_center      = h5f['x_center'][:]
y_center      = h5f['y_center'][:]
x_right       = h5f['x_right'][:]
y_top         = h5f['y_top'][:]
z_initial     = h5f['z_coords'][:]
vel_z_initial = h5f['vel_z'][:]
h5f.close()

# Considering a non-adaptive time-stepping, the time-step size for the entire simulation would be
dt = time[1] - time[0]

"""Declaring data variables which shall be used in post-processing"""

# These variables will be written to file at the end of every 100 time-steps
# This frequency of writing to the disc may be changed below

momentum_x     = np.zeros(time.size)
momentum_y     = np.zeros(time.size)
momentum_z     = np.zeros(time.size)
kinetic_energy = np.zeros(time.size)
pressure       = np.zeros(time.size)
heatflux_x     = np.zeros(time.size)
heatflux_y     = np.zeros(time.size)
heatflux_z     = np.zeros(time.size)

if(collision_operator == "potential-based"):
  potential_energy = np.zeros(time.size)

"""Choice for integrators"""

if(choice_integrator == "verlet"):
  from integrators.verlet import integrator

"""Setting the wall options"""

if(wall_condition_x == "thermal"):
  from wall_options.thermal import wall_x
elif(wall_condition_x == "hardwall"):
  from wall_options.hard_wall import wall_x
elif(wall_condition_x == "periodic"):
  from wall_options.periodic import wall_x

if(wall_condition_y == "thermal"):
  from wall_options.thermal import wall_y
elif(wall_condition_y == "hardwall"):
  from wall_options.hard_wall import wall_y
elif(wall_condition_y == "periodic"):
  from wall_options.periodic import wall_y

if(wall_condition_z == "thermal"):
  from wall_options.thermal import wall_z
elif(wall_condition_z == "hardwall"):
  from wall_options.hard_wall import wall_z
elif(wall_condition_z == "periodic"):
  from wall_options.periodic import wall_z

"""Collision Options"""

if(collision_operator == "montecarlo"):
  from collision_operators.monte_carlo import collision_operator

# We shall define a collision operator for the potential based model and collisionless models as well,
# Although integrator takes care of the scattering itself. The operator shall return the values as is
# This is to avoid condition checking inside the time-loop

if(collision_operator == "potential-based"):
  from collision_operators.potential import collision_operator

if(collision_operator == "collisionless"):
  from collision_operators.collisionless import collision_operator
# field_error_convergence(a, b) returns the errors in field variables calculated after the waves come 
# back to their initial position on a spatial grid with a*b dimensions




#Equations are:
# dBz/dt = - dEy/dx
# dEy/dt = - dBz/dx

# x, E in time n, n+1.............
# v, B in time n +0.5, n + 1.5 .....
# for Boris Algorithm : x(n+1) = x(n) + v(n+0.5)dt
#  v(n+1.5) = v(n + 0.5) + fields(E(n+1), B(avg(n+1.5,n+0.5)))


# For analytical comparision
# for x start from x(n+1) and for vx start from time (n+1)



def error(a,b):

    Nx = a
    Ny = b

    Lx = right_boundary - left_boundary
    Ly = top_boundary - bottom_boundary
    
    
    dx = Lx/Nx
    dy = Ly/Ny

    """ Setting the grids """

    x_center = np.linspace(-ghost_cells*dx, Lx + ghost_cells*dx, Nx + 1 + 2 * ghost_cells, endpoint=True)
    y_center = np.linspace(-ghost_cells*dy, Ly + ghost_cells*dy, Ny + 1 + 2 * ghost_cells, endpoint=True)

    """ Setting the offset spatial grids """


    x_right = np.linspace(-ghost_cells * dx / 2, Lx + (2 * ghost_cells + 1) * dx / 2, Nx + 1 + 2 * ghost_cells,\
                            endpoint=True\
                         )


    y_top = np.linspace(-ghost_cells * dy / 2, Ly + (2 * ghost_cells + 1) * dy / 2, Ny + 1 + 2 * ghost_cells,\
                          endpoint=True\
                       )


    """ Initial conditions for positions """
    # At n = 0
    x_initial = np.ones((no_of_particles), dtype = np.float)*Lx/2
    # At n = 0
    y_initial = np.ones((no_of_particles), dtype = np.float)*Ly/2
    # At n = 0

    """ Setting velocities according to maxwellian distribution """
    # At n = 0.5
    vel_x_initial = np.zeros(no_of_particles, dtype=np.float)
    vel_y_initial = np.zeros(no_of_particles, dtype=np.float)
    vel_z_initial = np.zeros(no_of_particles, dtype=np.float)

    vel_x_initial[:] = 0.2
    vel_y_initial[:] = 0.2

    """ Combining the initial conditions into one vector"""

    initial_conditions = np.concatenate([x_initial, y_initial,\
                                         z_initial, vel_x_initial,\
                                         vel_y_initial, vel_z_initial], axis=0)

    """ Electric and Magnetic field """

    Ez = np.zeros((len(x_center), len(y_center)), dtype=np.float)
    Bx = np.zeros((len(x_center), len(y_top)   ), dtype=np.float)
    By = np.zeros((len(x_right), len(y_center) ), dtype=np.float)

    Bz = np.zeros((len(x_center), len(y_center)), dtype=np.float)
    Ex = np.zeros((len(x_center), len(y_top)   ), dtype=np.float)
    Ey = np.zeros((len(x_right), len(y_center) ), dtype=np.float)

    """ Writing the spatial grids as a two dimension matrix for vectorization purposes """

    X_center_physical, Y_center_physical = np.meshgrid( x_center[ghost_cells:-ghost_cells],\
                                                        y_center[ghost_cells:-ghost_cells]\
                                                      )


    """ Discretizing time and making sure scaling is done right """

    # box_crossing_time_scale = length_of_box_x / np.max(initial_conditions_velocity_x)
    dt = np.float(dx / (2 * speed_of_light))
    time = np.arange(0, final_time, dt)

    """ Writing the offset spatial grids and indices as a two dimension matrix for vectorization purposes """

    X_right_physical, Y_top_physical = np.meshgrid( x_right[ghost_cells:-ghost_cells],\
                                                    y_top[ghost_cells:-ghost_cells]\
                                                  )

    I, J = np.meshgrid( range(ghost_cells, len(x_center) - ghost_cells),\
                        range(ghost_cells, len(y_center) - ghost_cells)\
                      )
    # Initializing the non relevant fields:

    Ey[ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = np.sin(2*np.pi*(-X_right_physical))
    Bz[ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = np.sin(2*np.pi*((dt/2)-X_right_physical))

    #Bz[ghost_cells:-ghost_cells, ghost_cells:-ghost_cells] = 20



    """ Boris method modified Verlet Integrator """


    def mag_Verlet(initial_conditions, t, F_interpolated):

        x = initial_conditions[0:no_of_particles]
        y = initial_conditions[no_of_particles:2 * no_of_particles]
        z = initial_conditions[2 * no_of_particles:3 * no_of_particles]
        v_x = initial_conditions[3 * no_of_particles:4 * no_of_particles]
        v_y = initial_conditions[4 * no_of_particles:5 * no_of_particles]
        v_z = initial_conditions[5 * no_of_particles:6 * no_of_particles]

        Ex = F_interpolated[0,0:no_of_particles]
        Ey = F_interpolated[1,0:no_of_particles]
        Ez = F_interpolated[2,0:no_of_particles]
        Bx = F_interpolated[3,0:no_of_particles]
        By = F_interpolated[4,0:no_of_particles]
        Bz = F_interpolated[5,0:no_of_particles]

        x_new = x + v_x * dt
        y_new = y + v_y * dt
        z_new = z + v_z * dt

        v_x_minus = v_x + (charge * Ex * dt) / (2 * mass_particle)
        v_y_minus = v_y + (charge * Ey * dt) / (2 * mass_particle)
        v_z_minus = v_z + (charge * Ez * dt) / (2 * mass_particle)

        t_magx = (charge * Bx * dt) / (2 * mass_particle)
        t_magy = (charge * By * dt) / (2 * mass_particle)
        t_magz = (charge * Bz * dt) / (2 * mass_particle)

        vminus_cross_t_x = (v_y_minus * t_magz) - (v_z_minus * t_magy)
        vminus_cross_t_y = -((v_x_minus * t_magz) - (v_z_minus * t_magx))
        vminus_cross_t_z = (v_x_minus * t_magy) - (v_y_minus * t_magx)

        v_dashx = v_x_minus + vminus_cross_t_x
        v_dashy = v_y_minus + vminus_cross_t_y
        v_dashz = v_z_minus + vminus_cross_t_z

        t_mag = np.sqrt(t_magx ** 2 + t_magy ** 2 + t_magz ** 2)

        s_x = (2 * t_magx) / (1 + abs(t_mag ** 2))
        s_y = (2 * t_magy) / (1 + abs(t_mag ** 2))
        s_z = (2 * t_magz) / (1 + abs(t_mag ** 2))

        v_x_plus = v_x_minus + ((v_dashy * s_z) - (v_dashz * s_y))
        v_y_plus = v_y_minus + -((v_dashx * s_z) - (v_dashz * s_x))
        v_z_plus = v_z_minus + ((v_dashx * s_y) - (v_dashy * s_x))

        v_x_new = v_x_plus + (charge * Ex * dt) / (2 * mass_particle)
        v_y_new = v_y_plus + (charge * Ey * dt) / (2 * mass_particle)
        v_z_new = v_z_plus + (charge * Ez * dt) / (2 * mass_particle)

        nextstep = np.concatenate([x_new, y_new, z_new, v_x_new, v_y_new, v_z_new], axis=0)
        return (nextstep)

    def analytical(Y,t):
      x, y, vx, vy = Y
      dydt = [ vx, vy, vy*np.sin(2*np.pi*(t + dt - x)), (1-vx)*np.sin(2*np.pi*(t + dt - x)) ]
      return dydt

    position_analytical = np.zeros((len(time),2), dtype = np.float)
    velocity_analytical = np.zeros((len(time),2), dtype = np.float)

    position_numerical = np.zeros((len(time),2), dtype = np.float)
    velocity_numerical = np.zeros((len(time),2), dtype = np.float)

    Num_error = np.zeros((len(time),2), dtype = np.float)


    """ Solving """

    old = np.zeros(6 * no_of_particles, dtype=np.float)



    old_analytical = np.zeros(6 * no_of_particles, dtype=np.float)


    from fields.interpolator import bilinear_interpolate
    from fields.fdtd import fdtd
    from scipy.integrate import odeint
    """ Solver """

    for time_index, t0 in enumerate(time):
        print("Computing for TimeIndex = ", time_index)
        # print('\n \n')
        t0 = time[time_index]
        if (time_index == time.size - 1):
            break
        t1 = time[time_index + 1]
        t = [t0, t1]
        if (time_index == 0):
            initial_conditions = initial_conditions

        else:
            initial_conditions = old

        Jx, Jy, Jz = 0, 0, 0
        Ex_updated, Ey_updated, Ez_updated, Bx_updated, By_updated, Bz_updated = fdtd(Ex, Ey, Ez, Bx, By, Bz, speed_of_light, Lx, Ly, ghost_cells, Jx, Jy, Jz)


        Ex_particle = np.array( bilinear_interpolate( x=[initial_conditions[:no_of_particles]], y=[initial_conditions[no_of_particles:2*no_of_particles]], x_grid=x_center,\
                                                      y_grid=y_top, F=Ex_updated, ghost_cells = ghost_cells, Lx = Lx, Ly = Ly\
                                                    )\
                              )

        Ey_particle = np.array( bilinear_interpolate( x=[initial_conditions[:no_of_particles]], y=[initial_conditions[no_of_particles:2*no_of_particles]], x_grid=x_right,\
                                                      y_grid=y_top, F=Ey_updated, ghost_cells = ghost_cells, Lx = Lx, Ly = Ly\
                                                    )\
                              )

        Ez_particle = np.array( bilinear_interpolate( x=[initial_conditions[:no_of_particles]], y=[initial_conditions[no_of_particles:2*no_of_particles]], x_grid=x_center,\
                                                      y_grid=y_top, F=Ez_updated, ghost_cells = ghost_cells, Lx = Lx, Ly = Ly\
                                                    )\
                              )

        Bx_particle = np.array( bilinear_interpolate( x=[initial_conditions[:no_of_particles]], y=[initial_conditions[no_of_particles:2*no_of_particles]], x_grid=x_right,\
                                                      y_grid=y_top, F=((Bx+Bx_updated)/2), ghost_cells = ghost_cells, Lx = Lx, Ly = Ly\
                                                    )\
                              )

        By_particle = np.array( bilinear_interpolate( x=[initial_conditions[:no_of_particles]], y=[initial_conditions[no_of_particles:2*no_of_particles]], x_grid=x_center,\
                                                      y_grid=y_top, F=((By+By_updated)/2), ghost_cells = ghost_cells, Lx = Lx, Ly = Ly\
                                                    )\
                              )

        Bz_particle = np.array( bilinear_interpolate( x=[initial_conditions[:no_of_particles]], y=[initial_conditions[no_of_particles:2*no_of_particles]], x_grid=x_right,\
                                                      y_grid=y_top, F=((Bz+Bz_updated)/2), ghost_cells = ghost_cells, Lx = Lx, Ly = Ly\
                                                    )\
                              )

        F_interpolated = np.concatenate([Ex_particle, Ey_particle, Ez_particle, Bx_particle, By_particle, Bz_particle], axis = 0)

        sol = mag_Verlet(initial_conditions, t, F_interpolated)


        if (time_index == 0):
            initial_conditions_analytical = [ \
                                               sol[0],sol[no_of_particles + 0] , \
                                               ((vel_x_initial[0]+sol[3*no_of_particles+0])/2), ((vel_y_initial[0]+sol[4*no_of_particles+0])/2)\
                                            ]
            # x,initial = x(n+1), vx_initial = avg(v(n+0.5,n+1.5)

            # all below from n = 1 (start is n = 0)

            initial_conditions_analytical = initial_conditions_analytical
            position_analytical[time_index,0] = initial_conditions_analytical[0] # x
            position_analytical[time_index,1] = initial_conditions_analytical[1] # y
            velocity_analytical[time_index, 0] = initial_conditions_analytical[2] # vx
            velocity_analytical[time_index, 1] = initial_conditions_analytical[3] # vy

        else:
            initial_conditions_analytical = old_analytical




        sol_analytical = odeint(analytical,initial_conditions_analytical,t)




        indices_right = np.where(sol[0:3*no_of_particles]>right_boundary)
        indices_left = np.where(sol[0:3*no_of_particles]<left_boundary)
        sol[indices_right] -= Lx
        sol[indices_left] += Lx


        if(sol_analytical[1, 0] > right_boundary):
            sol_analytical[1, 0]-=Lx
        if(sol_analytical[1, 0] < left_boundary):
            sol_analytical[1, 0]+=Lx


        if(sol_analytical[1, 1] > top_boundary):
            sol_analytical[1, 1]-=Ly
        if(sol_analytical[1, 1] < bottom_boundary):
            sol_analytical[1, 1]+=Ly




        # saving numerical data for position from n =1 timestep
        position_numerical[time_index, 0] = sol[0]
        position_numerical[time_index, 1] = sol[no_of_particles+0]

        # saving numerical data for velocity from n =1 timestep

        if(time_index == 0) :
            velocity_numerical[time_index, 0] = (sol[3*no_of_particles + 0] + vel_x_initial[0])/2 # n+1.5 and n+0.5
            velocity_numerical[time_index, 1] = (sol[4*no_of_particles + 0] + vel_y_initial[0])/2
        else:
            velocity_numerical[time_index, 0] = (sol[3*no_of_particles + 0] + old[3*no_of_particles + 0])/2
            velocity_numerical[time_index, 1] = (sol[4*no_of_particles + 0] + old[4*no_of_particles + 0])/2


        Ex, Ey, Ez, Bx, By, Bz= Ex_updated, Ey_updated, Ez_updated, Bx_updated, By_updated, Bz_updated

        old = sol

        old_analytical = sol_analytical[1, :]
        sol_analytical = sol_analytical[1, :]

        # saving analytical data starting from n = 1 timestep for both x and y, THat is 1st entry is n =1 timestep data for all

        position_analytical[time_index + 1, 0] = sol_analytical[0]
        position_analytical[time_index + 1, 1] = sol_analytical[1]
        velocity_analytical[time_index + 1, 0] = sol_analytical[2]
        velocity_analytical[time_index + 1, 1] = sol_analytical[3]


    h5f = h5py.File('data_files/time/solution'+str(a)+'.h5', 'w')
    h5f.create_dataset('data_files/time/solution_dataset'+str(a), data=time)
    h5f.close()


    h5f = h5py.File('data_files/posa/solution'+str(a)+'.h5', 'w')
    h5f.create_dataset('data_files/posa/solution_dataset'+str(a), data=position_analytical)
    h5f.close()

    h5f = h5py.File('data_files/posn/solution'+str(a)+'.h5', 'w')
    h5f.create_dataset('data_files/posn/solution_dataset'+str(a), data=position_numerical)
    h5f.close()

    h5f = h5py.File('data_files/vela/solution'+str(a)+'.h5', 'w')
    h5f.create_dataset('data_files/vela/solution_dataset'+str(a), data=velocity_analytical)
    h5f.close()

    h5f = h5py.File('data_files/veln/solution'+str(a)+'.h5', 'w')
    h5f.create_dataset('data_files/veln/solution_dataset'+str(a), data=velocity_numerical)
    h5f.close()
    return 1

error = np.vectorize(error)
N = np.array( [32, 64, 128, 256, 512 ] )


x = error(N, N)
print(x)
